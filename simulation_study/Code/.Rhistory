#   model = "OLS",
#   #coef_of_interest = c( "(Intercept)", "A"),  # "(Intercept)" or "A"
#   coef_of_interest = "A",
#   N = c(1000),
#
#   # MICE parameters
#   # as on cluster
#   imp_m = 50,  # also for Amelia
#   imp_maxit = 100,
#   mice_method = "norm",
#
#   # # for quicker sims
#   # imp_m = 5,
#   # imp_maxit = 5,
#   # N = c(100),
#
#   #dag_name = c( "1B", "1D", "1G", "1H" ),
#   dag_name = "1B"
# )
# remove combos that aren't implemented
scen.params = scen.params %>% filter( !(dag_name %in% c("1G", "1H", "1F") &
coef_of_interest == "(Intercept)") )
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 1  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
}
# RUN SIMULATION ------------------------------
# mimic Sherlock structure
if (run.local == TRUE) ( scens_to_run = scen.params$scen )
if (run.local == FALSE) ( scens_to_run = scen )  # from sbatch
sim.reps = 500
# BEGIN FOR-LOOP to run multiple scens locally
# if running on cluster, scen will just be length 1
for ( scen in scens_to_run ) {
if ( exists("rs") ) rm(rs)
if ( exists("rep.res") ) rm(rep.res)
# doParallel handles ONE scen at a time
# system.time is in seconds
# ~ ********** Beginning of ForEach Loop -----------------------------
doParallel.seconds = system.time({
rs = foreach( i = 1:sim.reps, .combine = bind_rows ) %dopar% {
#for debugging (out file will contain all printed things):
#for ( i in 1:4 ) {
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
coef_of_interest = p$coef_of_interest
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
( all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( exclude_from_imp_model = as.character( sim_obj$exclude_from_imp_model ) )
# coefficient of interest for gold-standard model
if ( coef_of_interest == "(Intercept)" ){
coef_of_interest_gold = "(Intercept)"
} else if ( coef_of_interest == "A:C"){
coef_of_interest_gold = "A1:C1"
} else {
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest_gold = paste(coef_of_interest, "1", sep = "")
}
# some methods don't make sense for certain combos of DAG and coef_of_interest
#@this happens when a variable needed for imputation model is also in the target law
#  later could deal with this by adding the variable back into dataset after imputation
if ( (p$dag_name == "1D" & coef_of_interest == "A") |
(p$dag_name == "1B" & coef_of_interest == "A") ) {
all.methods = all.methods[ !all.methods %in% c("MICE-ours", "Am-ours") ]
}
# ~ Make Imputed Data ------------------------------
# ~~ MVN-CC-std ----
# don't run for DAG 1J because it has no CCs by design
if ( "MVN-CC-std" %in% all.methods & !is.null(di_std) & p$dag_name != "1J" ) {
imps_mvn_cc_std = impute_mvn_cc( di_std,
m = p$imp_m )
# sanity check
imp1 = imps_mvn_cc_std[[1]]
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_mvn_cc_std = NULL
}
} else {
imps_mvn_cc_std = NULL
}
# ~~ MVN-CC-ours ----
if ( "MVN-CC-ours" %in% all.methods & !is.null(di_ours) & p$dag_name != "1J" ) {
imps_mvn_cc_ours = impute_mvn_cc( di_ours,
m = p$imp_m )
# sanity check
imp1 = imps_mvn_cc_std[[1]]
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_mvn_cc_ours = NULL
}
} else {
imps_mvn_cc_ours = NULL
}
# ~~ MICE-std ----
# details of how mice() implements pmm:
# ?mice.impute.pmm
if ( "MICE-std" %in% all.methods & !is.null(di_std) ) {
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m,
method = p$mice_method,
printFlag = FALSE )
# sanity check
imp1 = complete(imps_mice_std, 1)
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_mice_std = NULL
}
} else {
imps_mice_std = NULL
}
# ~~ MICE-ours ----
# MICE by restricting dataset
if ( "MICE-ours" %in% all.methods & !is.null(di_ours) ) {
imps_mice_ours = mice( di_ours,
maxit = p$imp_maxit,
m = p$imp_m,
method = p$mice_method,
printFlag = FALSE )
# sanity check
imp1 = complete(imps_mice_ours, 1)
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_mice_ours = NULL
}
} else {
imps_mice_ours = NULL
}
# ~~ MICE-ours-pred ----
# MICE by adjusting predictor matrix
if ( "MICE-ours-pred" %in% all.methods & !is.null(di_std) & !is.null(exclude_from_imp_model) ) {
# modify predictor matrix instead of restricting dataset
ini = mice(di_std, maxit=0)
pred = ini$predictorMatrix
pred[,exclude_from_imp_model] = 0
imps_mice_ours_pred = mice( di_std,
predictorMatrix = pred,
maxit = p$imp_maxit,
m = p$imp_m,
method = p$mice_method,
printFlag = FALSE )
# for later sanity checks
actual_pred = imps_mice_ours_pred$predictorMatrix
sums = colSums(actual_pred)  # if >0, means var was used in imp model
mice_ours_pred_vars_included = names( sums[ sums > 0 ] )
# sanity check
imp1 = complete(imps_mice_ours_pred, 1)
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_mice_ours_pred = NULL
}
} else {
imps_mice_ours_pred = NULL
}
# ~~ Am-std ----
if ( "Am-std" %in% all.methods & !is.null(di_std) ) {
imps_am_std = amelia( as.data.frame(di_std),
m=p$imp_m,
p2s = 0 # don't print output
)
imp1 = imps_am_std$imputations$imp1
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_am_std = NULL
}
} else {
imps_am_std = NULL
}
if ( "Am-ours" %in% all.methods & !is.null(di_ours) ) {
imps_am_ours = amelia( as.data.frame(di_ours),
m=p$imp_m,
p2s = 0 # don't print output
)
imp1 = imps_am_ours$imputations$imp1
if ( any(is.na(imp1)) ) {
message("MI left NAs in dataset - what a butt")
imps_am_ours = NULL
}
} else {
imps_am_ours = NULL
}
# ~ Initialize Global Vars ------------------------------
# initialize rep.res st run_method_safe and other standalone estimation fns
#  will correctly recognize it as having 0 rows
rep.res = data.frame()
# ~ Fit Models ------------------------------
# ~~ Gold standard: No missing data ----
if ( "gold" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("gold"),
method.fn = function(x) fit_regression(form_string = gold_form_string,
model = p$model,
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = coef_of_interest_gold,
miss_method = "gold",
du = du,
imps = NULL),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ Complete-case analysis (naive) ----
if ( "CC" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("CC"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = coef_of_interest,
miss_method = "CC",
du = di_std,
imps = NULL),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MVN-CC-std ----
# don't run for DAG 1J because it has no CCs by design
if ( "MVN-CC-std" %in% all.methods & !is.null(imps_mvn_cc_std) & p$dag_name != "1J" ) {
rep.res = run_method_safe(method.label = c("MVN-CC-std"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mvn_cc_std),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MVN-CC-ours ----
if ( "MVN-CC-ours" %in% all.methods & !is.null(imps_mvn_cc_ours)  & p$dag_name != "1J" ) {
rep.res = run_method_safe(method.label = c("MVN-CC-ours"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mvn_cc_ours),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MICE-std ----
if ( "MICE-std" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("MICE-std"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mice_std),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MICE-ours ----
if ( "MICE-ours" %in% all.methods & !is.null(imps_mice_ours) ) {
rep.res = run_method_safe(method.label = c("MICE-ours"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mice_ours),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MICE-ours-pred ----
if ( "MICE-ours-pred" %in% all.methods & !is.null(imps_mice_ours_pred) ) {
rep.res = run_method_safe(method.label = c("MICE-ours-pred"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mice_ours_pred),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ Am-std ----
if ( "Am-std" %in% all.methods & !is.null(imps_am_std) ) {
rep.res = run_method_safe(method.label = c("Am-std"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_am_std),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ Am-ours ----
if ( "Am-ours" %in% all.methods & !is.null(imps_am_ours) ) {
rep.res = run_method_safe(method.label = c("Am-ours"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_am_ours),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~ Add Scen Params and Sanity Checks --------------------------------------
# add in scenario parameters
# do NOT use rbind here; bind_cols accommodates possibility that some methods' rep.res
#  have more columns than others
rep.res = p %>% bind_cols( rep.res )
# these don't come from p because they are from sim_data instead
rep.res$coef_of_interest = coef_of_interest
rep.res$beta = beta
rep.res$form_string = form_string
rep.res$gold_form_string = gold_form_string
# add more info
rep.res = rep.res %>% add_column( rep.name = i, .before = 1 )
rep.res = rep.res %>% add_column( scen.name = scen, .before = 1 )
rep.res = rep.res %>% add_column( job.name = jobname, .before = 1 )
cat("\ndoParallel flag: Before adding sanity checks to rep.res")
# could add info about simulated datasets here
# preface them with "sancheck." to facilitate looking at sanchecks alone
# amount of missing data
# using di_std to avoid having R indicators, etc., in the dataset
if ( !is.null(di_std) ) {
rep.res = rep.res %>% add_column( sancheck.prop_complete = sum( complete.cases(di_std) ) / nrow(di_std) )
}
if ( !is.null(di_ours) ) {
rep.res = rep.res %>% add_column( sancheck.di_ours.vars = paste( names(di_ours), collapse = " " ) )
}
if ( exists("mice_ours_pred_vars_included") ){
if ( !is.null(mice_ours_pred_vars_included) ) {
rep.res = rep.res %>% add_column( sancheck.mice_ours_pred_vars_included = paste( mice_ours_pred_vars_included, collapse = " " ) )
}
}
cat("\n\n")
print(rep.res)
rep.res
}  ### end foreach loop
} )[3]  # end system.time
if ( run.local == TRUE ) {
# save locally and organize after this scen
setwd(data.dir)
fwrite( rs,
paste( "rs_scen_", scen, ".csv", sep = "" ) )
# also bind into new file
if ( scen == scens_to_run[1] ) rs_all_scens = rs
else rs_all_scens = bind_rows(rs_all_scens, rs)
}
}  # END FOR-LOOP to run multiple scens locally
# fill in true beta
beta_emp = rs_all_scens %>% filter(method == "gold") %>%
group_by(scen.name) %>%
summarise(beta = meanNA(bhat))
as.data.frame(beta_emp)
rs_all_scens = rs_all_scens %>% rowwise() %>%
mutate( beta = ifelse( !is.na(beta),
beta,
beta_emp$beta[ beta_emp$scen.name == scen.name ] ) )
t = rs_all_scens %>% group_by(method) %>%
summarise(
reps = n(),
Bhat = meanNA(bhat),
BhatBias = meanNA(bhat - beta),
BhatLo = meanNA(bhat_lo),
BhatHi = meanNA(bhat_hi),
BhatRMSE = sqrt( meanNA( (bhat - beta)^2 ) ),
BhatCover = meanNA( covers(truth = beta,
lo = bhat_lo,
hi = bhat_hi) ) ) %>%
arrange() %>%
mutate_if(is.numeric, function(x) round(x,2))
as.data.frame(t)
rm(list=ls())
# PRELIMINARIES ---------------------------------------------------------------
# This script uses renv to preserve the R environment specs (e.g., package versions.)
library(renv)
# run this if you want to reproduce results using the R environment we had:
# renv::restore()
to.load = c("dplyr",
"data.table",
"purrr",
"tidyr",
"stringr",
"tibble",
"ggplot2",
"testthat",
"plotly",
"htmlwidgets", # for saving plotly
"here",
"xtable",
"readxl")
# load within installation if needed
for (pkg in to.load) {
cat( paste("\nAbout to try loading package", pkg) )
tryCatch({
# eval below needed because library() will otherwise be confused
# https://www.mitchelloharawild.com/blog/loading-r-packages-in-a-loop/
eval( bquote( library( .(pkg) ) ) )
}, error = function(err) {
install.packages(pkg)
})
}
# run this only if you want to update the R environment specs
# renv::snapshot()
# set working directories
code.dir = here()
data.dir = str_replace_all( string = here(),
replacement = "Results/2025-04-01b - MVN-CC uses bootstrap",
pattern = "Code" )
results.dir = str_replace_all( string = here(),
replacement = "Results/2025-04-01b - MVN-CC uses bootstrap",
pattern = "Code" )
setwd(results.dir)  # check it
# # generic dirs (save)
# data.dir = str_replace_all( string = here(),
#                    replacement = "Simulation results/Working results",
#                    pattern = "Simulation code" )
#
# results.dir = str_replace_all( string = here(),
#                                replacement = "Simulation results/Working results",
#                                pattern = "Simulation code" )
# setwd(results.dir)  # check it
# below is the only absolute path
# write results directly to directory containing TeX manuscript in Overleaf so stats can be piped directly into text
# this is an absolute path because it must live in Dropbox, outside the project directory, in order to sync with Overleaf
# to reproduce results, just set this to any directory on your local machine
# results will be written to a csv file in that location
overleaf.dir.stats = "/Users/mmathur/Dropbox/Apps/Overleaf/IWN: Imputation without nightMARs (Overleaf)/R_objects"
setwd(overleaf.dir.stats)  # check it
# get helper fns
setwd(code.dir)
source("helper_IWN.R")
# no sci notation
options(scipen=999)
# read in dataset
setwd(data.dir)
agg = fread("agg.csv")
# set working directories
code.dir = here()
data.dir = str_replace_all( string = here(),
replacement = "Results/2025-04-01b - MVN-CC uses bootstrap",
pattern = "Code" )
results.dir = str_replace_all( string = here(),
replacement = "Results/2025-04-01b - MVN-CC uses bootstrap",
pattern = "Code" )
setwd(results.dir)  # check it
# # generic dirs (save)
# data.dir = str_replace_all( string = here(),
#                    replacement = "Simulation results/Working results",
#                    pattern = "Simulation code" )
#
# results.dir = str_replace_all( string = here(),
#                                replacement = "Simulation results/Working results",
#                                pattern = "Simulation code" )
# setwd(results.dir)  # check it
# below is the only absolute path
# write results directly to directory containing TeX manuscript in Overleaf so stats can be piped directly into text
# this is an absolute path because it must live in Dropbox, outside the project directory, in order to sync with Overleaf
# to reproduce results, just set this to any directory on your local machine
# results will be written to a csv file in that location
overleaf.dir.stats = "/Users/mmathur/Dropbox/Apps/Overleaf/IWN: Imputation without nightMARs (Overleaf)/R_objects"
setwd(overleaf.dir.stats)  # check it
# get helper fns
setwd(code.dir)
source("helper_IWN.R")
# no sci notation
options(scipen=999)
# read in dataset
setwd(data.dir)
agg = fread("agg.csv")
# check when it was created
file.info("agg.csv")$ctime
table(agg$method_pretty)
# reorder methods
correct_order = c("Benchmark", "Complete-case", "MVN (standard)", "Amelia (standard)", "MICE (standard)", "MVN (m-backdoor)", "Amelia (m-backdoor)", "MICE (m-backdoor)")
agg$method_pretty = factor(agg$method_pretty, levels = correct_order)
levels(agg$method_pretty)
table(agg$method_pretty)
### Table with all imputation methods (Supplement)
t = agg %>% select(dag_name_pretty, coef_of_interest_pretty, method_pretty, BhatBias, BhatRMSE, BhatCover) %>%
arrange( dag_name_pretty, coef_of_interest_pretty, method_pretty )
# to be filled in manually
t = t %>% add_column(aux_included = NA, .after = "coef_of_interest_pretty")
print( xtable(t), include.rownames = FALSE)
